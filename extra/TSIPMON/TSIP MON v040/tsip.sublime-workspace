{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"file": "iconv.c",
			"settings":
			{
				"buffer_size": 8341,
				"line_ending": "Windows"
			}
		},
		{
			"file": "iconv.h",
			"settings":
			{
				"buffer_size": 808,
				"line_ending": "Windows"
			}
		},
		{
			"file": "lcd_if.c",
			"settings":
			{
				"buffer_size": 15651,
				"line_ending": "Windows"
			}
		},
		{
			"file": "lcd_if.h",
			"settings":
			{
				"buffer_size": 1069,
				"line_ending": "Windows"
			}
		},
		{
			"file": "timer.h",
			"settings":
			{
				"buffer_size": 883,
				"line_ending": "Windows"
			}
		},
		{
			"file": "TSIP.h",
			"settings":
			{
				"buffer_size": 10459,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "//-----------------------------------------------------------------------------\n // TSIPMon.c\n//-----------------------------------------------------------------------------\n//\n// Program Description:\n//\n// This program uses a Silabs C8051F330 microcontroller and LCD display to \n// receive, decode and display time, position and status information from a \n// Trimble Thunderbolt GPS Disciplined Reference Oscillator.\n//\n// The data is transmitted serially from the Thunderbolt at 9600,8,N,1.\n// The default Thunderbolt configuration sends 2 packet types every second:\n// 	- Packet 0x8F-AB is the Primary Timing Packet\n// 	- Packet 0x8F-AC is the Supplemental Timing Packet.\n//\n//\n// Target:         C8051F330 + HD447870 compatible LCD display (2 lines x 16 char)\n// Tool chain:     SDCC 2.6.0\n//\n// Release 1.0\n//    -Initial Revision (DJ)\n//    -12 Jul 2009\n//\n// Copyright 2008-2010 Didier Juges \n// http://www.ko4bb.com\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program; if not, write to the \n// Free Software Foundation, Inc., \n// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n//\n//-----------------------------------------------------------------------------\n\n/*-----------------------------------------------------------------------------*\n*	Version\n*\n* Vers.  Date       Who        What\n* ====== ========== ========== ==========================\n* v0.0.1  7July08	D. Juges   Initial\n* v0.0.9 18July08   D. Juges   Changed messages\n* v0.1.1 25July08   D. Juges   Displays Temperature, \n* v0.1.2 29July08   D. Juges   Also displays DAC voltage,\n*                              Disciplining Mode and Rx Mode successively\n*                              by pressing SW1.\n* v0.1.3 2Aug08     D. Juges   Try a fix for randon turn off of Noritake?\n* v0.2.0 12Dec08    Dan Karg   Many changes/fixes additions\n* v0.2.1 28Dec08    D. Juges   Made LCD_PORT push-pull to fix problems with VFD\n* v0.2.2 1Jan09     D. Juges   Display DAC voltage with more decimals,\n*                              fix problem with temp and dac voltage\n* v0.2.3 10Dec10    D. Juges   Added choice of time zones\n* v0.3 0 11Dec10    D. Juges   Time zone and GPS offset works, P0.6 can be used\n*                              (by grounding) to revert to no time zone\n*                              P0.7 is used to select daylight savings time (when grounded)\n* v0.3.3 12Feb11    D. Juges   Fixed bug with time zone offset\n* v0.3.4 08Apr12    D. Juges   Added support for 2x20 LCD\n*------------------------------------------------------------------------------*/\n\n//-----------------------------------------------------------------------------\n// Includes\n//-----------------------------------------------------------------------------\n\n#include <C8051F330.h>                 // SFR declarations\n\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"general.h\"\n#include \"lcd_if.h\"\n#include \"timer.h\"\n#include \"TSIP.h\"\n#include \"iconv.h\"\n#include \"extdebug.h\"\n\n/*-----------------------------------------------------------------------------\n* Customizable constants\n*-----------------------------------------------------------------------------*/\n#define TIME_ZONE	-6	// -6 = Central time\n\n//#define TIME_ZONE 	-5	// -5 = Eastern time\n//#define TIME_ZONE 	-7	// -7 = Mountain time\n//#define TIME_ZONE 	-8	// -8 = Pacific time\n//#define TIME_ZONE 	-10	// -10 = Hawaii time\n//#define GPS_OFFSET 	15	// 15 seconds until the next leap second in July\n\n/*-----------------------------------------------------------------------------\n* version:\n*-----------------------------------------------------------------------------*/\ncode uchar VersionMsg[]     = \" TSIPMon v0.3.4     \";  // make 20 char long\ncode uchar LCDInitMsg[] 	= \" www.ko4bb.com      \";  // make 20 char long\n\n\n//-----------------------------------------------------------------------------\n// Global Constants\n//-----------------------------------------------------------------------------\n#define INTERRUPT_UART0         4  // Serial Port 0\n\n#define SYSCLK             24500000/8  // SYSCLK in Hz (24.5 MHz internal\n                                       // oscillator / 8)\n                                       // the internal oscillator has a\n                                       // tolerance of +/- 2%\n\n#define TIMER_PRESCALER            12  // Based on Timer2 CKCON and TMR2CN\n                                       // settings\n\n#define TIMER_RATE                2  // LED toggle rate in milliseconds\n                                       // if LED_TOGGLE_RATE = 1, the LED will\n                                       // be on for 1 millisecond and off for\n                                       // 1 millisecond\n\n// There are SYSCLK/TIMER_PRESCALER timer ticks per second, so\n// SYSCLK/TIMER_PRESCALER/1000 timer ticks per millisecond.\n#define TIMER_TICKS_PER_MS  SYSCLK/TIMER_PRESCALER/1000\n\n// Note: LED_TOGGLE_RATE*TIMER_TICKS_PER_MS should not exceed 65535 (0xFFFF)\n// for the 16-bit timer\n\n#define AUX1     TIMER_TICKS_PER_MS*TIMER_RATE\n#define AUX2     -AUX1\n\n#define TIMER2_RELOAD            AUX2  // Reload value for Timer2\n\n#define LED  	P1_3                   // LED='1' means ON\n\n#define SW2 	P0_1	// /INT0	// right switch (pin 1 of F330D)\n#define SW1 	P0_2	// /INT1	// left switch (pin 0 of F330D)\n#define LED1	P0_3	// green LED\n//#define LED2	P0_7	// red LED\n\n#define OFFSET_SELECT	P0_6	// pin 18 on the 20 pin DIP package\n								// ground this pin to display GPS time\n							// leave open to display time in selected time zone\n#define DST_SELECT		P0_7\n\n/* ===== GPS Stuff ===== */\n#define ETX								0x03\n#define DLE								0x10\n#define IO_BUF_ID_INDEX					1\n#define IO_BUF_ID2_INDEX				2\n\n#define SUPERPACKET						0x8F\n#define PRIMARY_TIMING_PCKT				0xAB\n#define PRIMARY_TIMING_PCKT_LEN			17\n#define SUPPLEMENTAL_TIMING_PCKT		0xAC\n#define SUPPLEMENTAL_TIMING_PCKT_LEN	60\n\ncode uchar prompt[2][9]={\n	\"TEMP:  \",\n	\"DAC V: \"\n};\n\n\n\n/* ===== Global Variables ===== */\n\n/* ----- Timers ----- */\nTIMERDEF Timer[NUM_TIMERS];\n\nstatic uchar TxRx_State;\nstatic uchar TxRx_Count;\n\nbit Rx_Pending;\nbit Tx_In_Progress;\n\nINTType xdata Alarms;\n\n// static uchar TXRX_STORAGE_CLASS *p_TxRx_Buf;\n// uchar TXRX_STORAGE_CLASS TxRxBuf[TXRX_BUF_LEN];\n\nbit switch2, switch1, func2, func1, err1;\n\nuchar LCD_STORAGE_CLASS lcdbuf[LCD_SIZE+1];\n\nchar tz = TIME_ZONE;	\nuchar gpsoffset;// = GPS_OFFSET;\n\n/* ===== External variables ===== */\n// extdebug.c\nextern code uchar ALARM_MSG[NUM_ALARMS][];	\n\n// iconv.c\n//extern uchar lzb;	\n\n//-----------------------------------------------------------------------------\n// Function Prototypes\n//-----------------------------------------------------------------------------\n\nvoid Port_Init( void );                 // Port initialization routine\nvoid Timer2_Init( void );               // Timer2 initialization routine\nvoid UART0_Init( void );\nvoid WaitTicks( uint );\nvoid ProcessRxMsg( void );\nvoid PrimaryTiming( uchar TXRX_STORAGE_CLASS * );\nvoid SupplementalTiming( uchar TXRX_STORAGE_CLASS *RxBuf );\nvoid UnsignedToAscii( uint, uchar TXRX_STORAGE_CLASS *, uchar );\n// void IntToAscii( int value, uchar TXRX_STORAGE_CLASS *pbuf, uchar nbdigits );\nvoid TimerStart( uchar timer_num, uint num_ticks );\nbit TimerReady( uchar timer_num );\nbit TimerRunning( uchar timer_num );\nvoid clr_LCDBuf( void );\n\n//-----------------------------------------------------------------------------\n// Global Variables\n//-----------------------------------------------------------------------------\n\n//sfr16 TMR2RL = 0xCA;                   // Timer2 Reload Register\n//sfr16 TMR2 = 0xCC;                     // Timer2 Register\n\nuint ticks = 0;\n\nstatic uchar TXRX_STORAGE_CLASS *p_TxRx_Buf;\nuchar TXRX_STORAGE_CLASS TxRxBuf[TXRX_BUF_LEN];\n\n/*-----------------------------------------------------------------------------\n* extern variables\n*-----------------------------------------------------------------------------*/\n\n//-----------------------------------------------------------------------------\n// main() Routine\n//-----------------------------------------------------------------------------\n\nvoid main( void ){\n\n	PCA0MD &= ~0x40;					// Clear watchdog timer enable\n\n	Timer2_Init();						// Initialize the Timer2\n	Port_Init();						// Init Ports\n	UART0_Init();\n	EA = TRUE;							// Enable global interrupts\n	LED = 0;							// turn ON LED\n	//LED2 = 1;							// turn ON LED2\n	LED1 = 1;							// turn ON LED1\n	TimerStart( SYS_TIMER, 500 );		// wait for display to wake up\n	while( !TimerReady( SYS_TIMER ))\n		;\n	InitLCD();							// Init LCD Controller\n	ClearLCD( 3 );						// Clear display\n	printCode2LCD( 1, VersionMsg, 0 );\n	printCode2LCD( 2, LCDInitMsg, 0 );\n	\n	TimerStart( SYS_TIMER, 1500 );\n	while( !TimerReady( SYS_TIMER ))\n		;\n	ClearLCD( 3 );\n\n	if( OFFSET_SELECT == 1 ){\n		strcpy( lcdbuf, \"Time Zone : \" );\n		CharToAscii( tz, lcdbuf+12, 3 );\n		printLCD( 1, lcdbuf, 0 );\n		strcpy( lcdbuf, \"GPS offset: Auto\" );\n		//CharToAscii( gpsoffset, lcdbuf+12, 3 );\n		printLCD( 2, lcdbuf, 0 );\n		TimerStart( SYS_TIMER, 1500 );\n		while( !TimerReady( SYS_TIMER ))\n			;\n		ClearLCD( 3 );\n		//TimerStart( SYS_TIMER, 500 );		// wait for display to wake up\n		//while( !TimerReady( SYS_TIMER ))\n		//	;\n		clr_LCDBuf();\n	}\n\n\n	//LED2 = 0;							// turn OFF LED2\n	LED1 = 0;							// turn OFF LED1\n	func2 = FALSE;\n	func1 = FALSE;\n	err1 = FALSE;\n\n	printCode2LCD( 1, \"Waiting for GPS\", 0 );\n	TimerStart( SYS_TIMER, 1500 );\n	while( !TimerReady( SYS_TIMER ))\n		;	\n	LED = 1;							// turn OFF LED\n	TimerStart( SWITCH_TIMER, 50 );		// switch timer\n\n	while( 1 ){							// Loop forever\n		if( Rx_Pending ){\n			TimerReset( SYS_TIMER );\n			ProcessRxMsg();\n			TimerStart( SYS_TIMER, 1200 );\n			err1 = FALSE;\n		}\n		if( TimerReady( SYS_TIMER )){\n			if( !err1 ){\n				TimerStart( SYS_TIMER, 1200 );\n				printCode2LCD( 1, \"   No Message   \", 0 );\n//				printCode2LCD( 2, \"  Check GPS RX  \", 0 );\n				err1 = TRUE;\n			}else{\n				TimerStart( SYS_TIMER, 500 );\n				ClearLCD( 3 );\n				err1 = FALSE;\n			}\n		}\n\n		if( TimerReady( SWITCH_TIMER )){\n			switch1 = 1;\n			switch2 = 1;\n			TimerReset( SWITCH_TIMER );\n		}\n   	}\n\n}  // main()\n\n//-----------------------------------------------------------------------------\n// Initialization Subroutines\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Port_Init\n//-----------------------------------------------------------------------------\n//\n// Return Value : None\n// Parameters   : None\n//\n// This function configures the crossbar and GPIO ports.\n//\n// Pinout:\n//\n//	P0.0 -> VRef (not used)\n//	P0.1 -> /INT0 -> switch 1 (active low)\n//	P0.2 -> /INT1 -> switch 2 (active low)\n//	P0.3 -> LED 1 (active high)\n//	P0.4 -> Tx (not used)\n//	P0.5 -> Rx\n//  P0.6 -> input (GPS offset select)\n//	//P0.7 -> LED 2 (active high)\n//  P0.7 -> input (DST select)\n//\n//	P1.x -> LCD Display\n//\n//-----------------------------------------------------------------------------\nvoid Port_Init( void ){\n\n	P0SKIP    = 0x01;					// P0.0 -> Vref\n//    P0MDOUT = 0x98;						// Tx, LED2, LED1 are push-pull\n    P0MDOUT = 0x18;						// Tx, LED1 are push-pull\n	XBR0 = 0x01;						// enable UART\n	XBR1 = 0x40;                        // Enable crossbar\n	//P1MDOUT = 0x08;                     // Set LED2 to push-pull\n	P1MDOUT = 0x7F;						// make LCD_PORT push-pull (except busy flag) v021\n\n	// set PO.1 to be /INT0 and P0.2 to be /INT1\n	IE        |= 0x05;		// enable /INT0 and /INT1\n	IT01CF    = 0x21;		// /INT0 and /INT1 active low, P0.1 and P0.2 respectively\n	// for /INT0 Interrupt Active low, edge sensitive,\n	// set IT0 = 1	and IN0PL = 0		\n	// for /INT1 Interrupt Active low, edge sensitive,\n	// set IT1 = 1	and IN1PL = 0	\n	// IN0PL and IN1PL are in IT01CF\n	// IT0 and IT1 are in TCON\n	IT0 = 1;	// /INT0 edge triggered\n	IT1 = 1;	// /INT1 edge triggered\n\n	\n\n}  // Port_Init()\n\n//-----------------------------------------------------------------------------\n// Timer2_Init\n//-----------------------------------------------------------------------------\n//\n// Return Value : None\n// Parameters   : None\n//\n// This function configures Timer2 as a 16-bit reload timer, interrupt enabled.\n// Using the SYSCLK at 16MHz/8 with a 1:12 prescaler.\n//\n// Note: The Timer2 uses a 1:12 prescaler.  If this setting changes, the\n// TIMER_PRESCALER constant must also be changed.\n//-----------------------------------------------------------------------------\nvoid Timer2_Init( void ){\n\n	uchar i;\n	// I think this should be 0x30 DAK\n	CKCON &= ~0x60;                     // Timer2 uses SYSCLK/12\n	TMR2CN &= ~0x01;					// Set bit 0 low, select SYSCLK/12\n\n	TMR2RL = TIMER2_RELOAD;             // Reload value to be used in Timer2\n	TMR2 = TMR2RL;                      // Init the Timer2 register\n\n	TMR2CN = 0x04;                      // Enable Timer2 in auto-reload mode\n	ET2 = 1;                            // Timer2 interrupt enabled\n\n	for( i = 0; i < NUM_TIMERS; i++ ){	// Initialize software timers.\n		Timer[i].Status = 0;\n		Timer[i].WaitTime = 0;\n	}\n\n}  // Timer2_Init()\n\n\n//-----------------------------------------------------------------------------\n// Interrupt Service Routines\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Timer2_ISR\n//-----------------------------------------------------------------------------\n//\n// Here we process the Timer2 interrupt and toggle the LED\n//\n//-----------------------------------------------------------------------------\nvoid Timer2_ISR( void ) interrupt 5{\n\n	uchar i;\n\n//	LED1 = !LED1;                         	// Toggle the LED\n	TF2H = 0;                           	// Reset Interrupt\n	if( ticks > 0 )\n		ticks--;\n	for( i = 0; i < NUM_TIMERS; i++ ){		// Cycle through all timers, to update.\n		if( Timer[i].WaitTime > 0 ){		// Is it Expired?\n			Timer[i].WaitTime--;			// No: Count it down.\n			Timer[i].Status = TIMER_STATUS_RUNNING;\n		}else{								// Yes: Flag it as 'ready'.\n			Timer[i].Status = TIMER_STATUS_READY;\n		}\n	}										// No: Skip it.\n\n}  // Timer2_ISR()\n\n/*---------------------------------------------------------------------*\n* FUNCTION: void WaitTicks( uint delay );\n*\n*This function waits for 'delay' mS to pass.\n*----------------------------------------------------------------------*/\nvoid WaitTicks( uint delay){\n\n	EA = FALSE;\n	ticks = delay;\n	EA = TRUE;\n	while( ticks > 0 )\n		;\n\n}  // WaitTicks()\n\n/*---------------------------------------------------------------------*\n* FUNCTION: TimerStart()\n*\n*	Arguments: 	timer_num = Timer Number\n*		num_ticks = number of 1mS clock ticks\n*\n*	Initiates a timer function.  The time is in system time base units\n*	( 1 ms ).  The timer is enabled and will start counting down\n*	at the next time base interrupt.\n*---------------------------------------------------------------------*/\nvoid TimerStart( uchar timer_num, uint num_ticks ){\n\n	INT_DISABLE;\n\n	Timer[timer_num].WaitTime	= num_ticks;\n	Timer[timer_num].Status	= TIMER_STATUS_RUNNING;\n\n	INT_ENABLE;\n\n}   // end TimerStart()\n\n/*---------------------------------------------------------------------*\n*  FUNCTION: TimerRunning()\n*\n*---------------------------------------------------------------------*/\nbit TimerRunning( uchar timer_num ){\n\n	return( (Timer[timer_num].Status == TIMER_STATUS_RUNNING)?TRUE:FALSE );\n\n}  // TimerRunning()\n\n/*---------------------------------------------------------------------*\n*  FUNCTION: TimerReset()\n*\n*---------------------------------------------------------------------*/\nvoid TimerReset( uchar timer_num ){\n\n	INT_DISABLE;\n    Timer[timer_num].WaitTime	= 0;\n    Timer[timer_num].Status	= TIMER_STATUS_STOPPED;\n	INT_ENABLE;\n\n} // end TimerReset()\n\n/*---------------------------------------------------------------------*\n*  FUNCTION:  TimerReady()\n*---------------------------------------------------------------------*/\nbit TimerReady( uchar timer_num ){\n\n    if( Timer[timer_num].Status == TIMER_STATUS_READY )\n		return( TRUE );\n    else\n		return( FALSE );\n\n} // end TimerReady()\n\n// DAK disable unreachable code warning for this section\n#pragma save\n#pragma disable_warning 126\n//-----------------------------------------------------------------------------\n// UART0_Init\n//-----------------------------------------------------------------------------\n//\n// Return Value : None\n// Parameters   : None\n//\n// Configure the UART1 using Timer1, for <baudrate> and 8-N-1.\n//\n//-----------------------------------------------------------------------------\nvoid UART0_Init( void ){\n\n   SCON0 = 0x10;                       // SCON0: 8-bit variable bit rate\n                                       //        level of STOP bit is ignored\n                                       //        RX enabled\n\n                                       //        ninth bits are zeros\n                                       //        clear RI0 and TI0 bits\n\n\n\n   if( SYSCLK/BAUDRATE/2/256 < 1 ){\n      TH1 =  (unsigned char) -(SYSCLK/BAUDRATE/2);\n      CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx\n      CKCON |=  0x08; \n   }else if( SYSCLK/BAUDRATE/2/256 < 4 ){\n      TH1 = (unsigned char) -(SYSCLK/BAUDRATE/2/4);\n      CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01\n      CKCON |=  0x09;\n   }else if( SYSCLK/BAUDRATE/2/256 < 12 ){\n      TH1 = (unsigned char) -(SYSCLK/BAUDRATE/2/12);\n      CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00\n   }else{\n      TH1 = (unsigned char) -(SYSCLK/BAUDRATE/2/48);\n      CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10\n      CKCON |=  0x02; \n   }\n\n\n	TL1 = TH1;                          // Init Timer1\n	TMOD &= ~0xf0;                      // TMOD: timer 1 in 8-bit autoreload\n	TMOD |=  0x20;\n	TR1 = 1;                            // START Timer1\n	TI0 = 1;                            // Indicate TX0 ready\n\n	/* from Configurer\n    TMOD      = 0x20;\n    CKCON     = 0x08;\n    TH1       = 0x60;\n	*/\n\n   	RI0 = FALSE;		// turn off any pending receive interrupt\n	REN0 = TRUE;		// UART0 receive enable\n	ES0 = TRUE;         // UART0 interrupt enable\n\n}  // UART0_Init()\n\n#pragma restore\n/*---------------------------------------------------------------------*\n*  Serial Port Interrupt Service\n*----------------------------------------------------------------------*/\nvoid SioIntService( void ) interrupt INTERRUPT_UART0 using SIO_REG_BANK {\n\n	uchar tchar;\n	static bit bEvenDLE;\n	\n\n	// Receiver Section\n	if( RI0 ){\n		tchar = SBUF0;	// & PARITY_MASK;\n		RI0 = FALSE;\n\n		// Prohibit Buffer Overrun\n		if( TxRx_Count > TXRX_BUF_LEN - 1 ) {\n			TxRx_State = WAIT_FOR_START;\n			TxRx_Count = 0;\n			return;\n		}\n\n		switch( TxRx_State ){\n			case WAIT_FOR_START:\n				// actually this waits for an end-of-message sequence\n				// Phase Receiver with char-DLE-ETX\n				if( tchar == DLE ){\n					TxRx_Count = 0;\n					TxRxBuf[TxRx_Count++] = tchar;\n					TxRx_State = WAIT_FOR_ID;\n				}else if( tchar != ETX ){\n					TxRx_State = WAIT_FOR_DLE_ETX;\n					Rx_Pending = FALSE;\n					TxRx_Count = 0;\n				}\n				bEvenDLE = FALSE;\n				break;\n\n			case WAIT_FOR_DLE_ETX:\n				if( tchar == DLE )\n					TxRx_State = WAIT_FOR_ETX;\n				else\n					TxRx_State = WAIT_FOR_START;\n				break;\n\n			case WAIT_FOR_ETX:  // rarely happens\n				if( tchar == ETX )	\n					// found end of a message\n					TxRx_State = WAIT_FOR_DLE;\n				else\n					TxRx_State = WAIT_FOR_START;\n				break;\n\n			case WAIT_FOR_DLE:\n				if( tchar == DLE ){\n					TxRx_Count = 0;\n					TxRxBuf[TxRx_Count++] = tchar;\n					TxRx_State = WAIT_FOR_ID;\n				}else\n					TxRx_State = WAIT_FOR_START;\n				bEvenDLE = FALSE;\n				break;\n\n			case WAIT_FOR_ID: // never happens\n				if( tchar == DLE || tchar == ETX ){\n					TxRx_State = WAIT_FOR_START;\n					TxRx_Count = 0;\n				}else{\n					TxRx_State = WAIT_FOR_END_MSG;\n					TxRxBuf[TxRx_Count++] = tchar;\n				}\n				break;\n\n			case WAIT_FOR_END_MSG:\n				if( tchar == DLE && TxRxBuf[TxRx_Count-1] == DLE && !bEvenDLE ){\n					// byte stuffing\n					bEvenDLE = TRUE;\n				}else if( tchar == ETX && TxRxBuf[TxRx_Count-1] == DLE && !bEvenDLE ){\n					// complete message received, in buffer\n					//P0_6 = 0;	// 7\n					Rx_Pending = TRUE;\n					TxRxBuf[TxRx_Count] = '\\0';\n					TxRx_State = WAIT_FOR_DLE;\n\n					//P0_6 = 1;\n				}else{\n					TxRxBuf[TxRx_Count++] = tchar;\n					bEvenDLE = FALSE;\n				}\n				break;\n\n			default:\n				TxRx_State = WAIT_FOR_START;\n				break;\n		}\n\n	}else{\n        // Transmitter Section\n        if( TI0 ){\n			TI0 = FALSE;\n\n            if( !Tx_In_Progress ){\n                RI0 = FALSE;\n                Tx_In_Progress = FALSE;\n                Rx_Pending = FALSE;\n				return;\n			}\n			switch( TxRx_State ){\n\n				case SEND_HDR:\n					SBUF0 = DLE;\n					TxRx_State = SEND_MSG;\n					TxRx_Count--;\n					p_TxRx_Buf = TxRxBuf+1;\n					bEvenDLE = FALSE;\n					break;\n\n				case SEND_MSG:\n		            tchar = *p_TxRx_Buf;\n					SBUF0 = tchar;\n					if( tchar == DLE && !bEvenDLE && TxRx_Count > 1 ){\n						// do DLE byte stuffing\n						bEvenDLE = TRUE;\n						return;\n					}\n					p_TxRx_Buf++;\n					bEvenDLE = FALSE;\n					if( TxRx_Count-- == 0 ){\n		                Tx_In_Progress = FALSE;\n		                TxRx_Count = 0;\n		            }\n					break;\n\n				default:\n					break;\n            }\n        }	// end if( TI )\n    }	// end if( ! RI )\n\n    return;\n\n\n} // end SioIntService()\n\n/*-----------------------------------------------------------------------------*\n*	Function: ProcessRxMsg()\n*------------------------------------------------------------------------------*/\nvoid ProcessRxMsg( void ){\n\n	uchar TXRX_STORAGE_CLASS pBuf[TXRX_BUF_LEN];\n	uchar i;\n	uchar id, id2;\n\n	id = TxRxBuf[IO_BUF_ID_INDEX];\n	id2 = TxRxBuf[IO_BUF_ID2_INDEX];\n	for( i=2; i<TxRx_Count; i++)\n		pBuf[i-2] = TxRxBuf[i];\n	Rx_Pending = FALSE;\n\n	switch( id ){\n		case SUPERPACKET:\n			switch( id2 ){\n				case PRIMARY_TIMING_PCKT:\n					PrimaryTiming( pBuf );\n					break;\n\n				case SUPPLEMENTAL_TIMING_PCKT:\n					SupplementalTiming( pBuf );\n					break;\n\n				default:\n					break;\n			}\n		default:\n			break;\n	}\n\n}  // ProcessRxMsg()\n\n/*-----------------------------------------------------------------------------*\n* Function: PrimaryTiming()\n*\n*	Display time and date on top line of the display\n*------------------------------------------------------------------------------*/\nvoid PrimaryTiming( uchar TXRX_STORAGE_CLASS *RxBuf ){\n\n	char sec, min, hr, dom, mo, y;\n	UINTType yr;\n	//int utcoffset;\n	char ctz;\n\n	ctz = tz;\n\n	yr.b.hi = *(RxBuf+7);\n	yr.b.lo = *(RxBuf+8);\n	gpsoffset = yr.i;\n\n	// decode date/time from packet\n	sec = *(RxBuf+10);\n\n	min = *(RxBuf+11);\n\n	hr = *(RxBuf+12);\n\n	dom = *(RxBuf+13);\n\n	mo = (*(RxBuf+14)-1)*3;	// note: mo starts at 0 (January)\n\n	yr.b.hi = *(RxBuf+15);\n	yr.b.lo = *(RxBuf+16);\n\n	y = yr.u - 2000;\n\n	// if apply GPS offset...\n	if( OFFSET_SELECT == 0 ){\n		// compute effect of GPS offset\n		sec -= gpsoffset;\n		if( sec < 0 ){\n			sec += 60;\n			min--;\n			if( min < 0 ){\n				min += 60;\n				hr--;\n				if( hr < 0 ){\n					hr += 24;\n					ctz--;\n				}\n			}\n		}\n\n		// compute for time zone\n		if( ctz > 0 ){\n			hr += ctz;\n			if( DST_SELECT == 0 )\n				hr++;\n			if( hr > 23 ){\n				hr -= 24;\n				dom++;\n				if( (uchar)dom > DIM[mo] ){\n					// check for leap year ***TODO\n					dom = 0;\n					mo++;\n					if( mo > 11 ){\n						mo = 0;\n						y++;\n					}\n				}\n			}\n		}\n		if( ctz < 0 ){\n			hr += ctz;\n			if( DST_SELECT == 0 )\n				hr++;\n			if( hr < 0 ){\n				hr += 24;\n				dom--;\n				if( dom < 0 ){\n					mo--;\n					if( mo < 0 ){\n						mo = 12;\n						y--;\n					}\n					dom = DIM[mo];\n					// check for leap year ***TODO\n				}\n			}\n		}\n	}\n\n	// display on LCD\n	UnsignedToAscii( (uint)sec, lcdbuf+6, 2 );\n	if( lcdbuf[6] == ' ' ) lcdbuf[6] = '0';\n	lcdbuf[8] = ' ';\n\n	UnsignedToAscii( (uint)min, lcdbuf+3, 2 );\n	if( lcdbuf[3] == ' ' ) lcdbuf[3] = '0';\n	lcdbuf[5] = ':';\n\n	UnsignedToAscii( (uint)hr, lcdbuf, 2 );\n	if( lcdbuf[0] == ' ' ) lcdbuf[0] = '0';\n	lcdbuf[2] = ':';\n\n	// Display day-of-month\n	UnsignedToAscii( (uint)dom, lcdbuf+9, 2 );\n	// DAK add leading zero to date \n	if( lcdbuf[9] == ' ' ) lcdbuf[9] = '0';\n\n	// Display month\n	lcdbuf[11] = Month[mo];\n	lcdbuf[12] = Month[mo+1];\n	lcdbuf[13] = Month[mo+2];\n\n	// Display year\n	UnsignedToAscii( (uint)y, lcdbuf+14, 2 );\n	if( lcdbuf[14] == ' ' ) lcdbuf[14] = '0';\n	lcdbuf[16] = '\\0';\n\n	if( OFFSET_SELECT == 1 ){ \n		lcdbuf[16] = ' ';\n		lcdbuf[17] = 'G';\n		lcdbuf[18] = 'P';\n		lcdbuf[19] = 'S';\n		lcdbuf[20] = '\\0';\n	}else{\n		lcdbuf[16] = ' ';\n		lcdbuf[17] = 'C';\n		if( DST_SELECT == 0 )\n			lcdbuf[18] = 'D';\n		else\n			lcdbuf[18] = 'S';\n		lcdbuf[19] = 'T';\n		lcdbuf[20] = '\\0';\n	}\n\n//	printLCD( 1, lcdbuf, 0 );\n\n	//offset.b.hi = *(RxBuf+7);\n	//offset.b.lo = *(RxBuf+8);\n	//UnsignedToAscii( (uint)RxBuf[8], lcdbuf, 2 );\n	//printLCD( 2, lcdbuf, 0 );\n\n\n}  // PrimaryTiming()\n\n/*-----------------------------------------------------------------------------*\n* Function: SupplementalTiming()\n*\n*	Diay various GPS receiver status info on second line of display\n*-----------------------------------------------------------------------------*/\nvoid SupplementalTiming( uchar TXRX_STORAGE_CLASS *RxBuf ){\n//#define TEST_EXTDEBUG\n\n#define NUM_DISPLAY_MODES		6\n\n	static bit b = FALSE;\n	static bit c = FALSE;\n\n	FLOATType temp;\n	uchar val;\n	uint fval;\n	//char dac;\n	//char tempbuf[17];\n	static char mode = -1;\n\n#ifdef TEST_EXTDEBUG\n	if( Alarms.u == 0 )\n		Alarms.u = 1;\n	else\n		Alarms.u = Alarms.u<<1;\n#else\n\n	printLCD( 1, lcdbuf, 0 );	// print 1st line\n\n	// Critical alarms are lower 5 bits of byte 8-9 (so they are in Byte 9)\n	// Minor alarms are lower 9 bits of byte 10-11 (lower bits are in byte 11)\n	// Load Minor Alarms\n	Alarms.b.hi = RxBuf[10];\n 	Alarms.b.lo = RxBuf[11];\n	// shift them up by 5 to make room for Critical Alarms\n	Alarms.u = Alarms.u<<5;\n	// OR with Critical Alarms\n	Alarms.b.lo |= RxBuf[9];\n#endif\n\n	c = !c;  // only change display every 2nd time thru ( about every 2 seconds)\n	if( c )\n		return;\n\n	ClearLCD( 2 );\n	if( Alarms.u != 0 && mode == NUM_DISPLAY_MODES - 1 ){\n		b = Fault_Msg_Query( Alarms.u, lcdbuf, ALARM_MSG[0] );\n		if( b )\n			printLCD( 2, lcdbuf, 0 ); \n		if( RxBuf[9] != 0 ) // if critical alarm, keep showing it\n			return;        \n	}\n\n	if( !b ){\n		if( ++mode >= NUM_DISPLAY_MODES )\n			mode = 0;\n\n		val = 28;\n		fval = 10000;\n		switch( mode ){\n			case 0:	// disciplining mode\n				strcpy( lcdbuf , DiscMode[RxBuf[2]]);\n				break;\n\n			case 1:	// Discipling Activity\n				strcpy( lcdbuf , DiscActivity[RxBuf[13]]);\n				break;\n\n			case 2:	// Receiver mode\n				strcpy( lcdbuf , RxMode[RxBuf[1]]);\n				break;\n\n			case 3:	// GPS Decode Status\n				strcpy( lcdbuf , GPSDecodeStatus[RxBuf[12]]);\n				break;\n\n			case 4:	// RxBuf[32-35] is temperature (float)\n				val = 32;\n				fval = 100;\n				// intentionally falls through (no break)\n\n			case 5:	// RxBuf[28-31] is DAC Voltage (float)\n				temp.b.hhi = RxBuf[val];\n				temp.b.hi = RxBuf[val+1];\n				temp.b.lo = RxBuf[val+2];\n				temp.b.llo = RxBuf[val+3];\n\n				val = temp.f;\n				fval = ((temp.f - val) * fval);\n\n				// ***TEST\n				//val = 249;\n				//fval = 209;\n\n				strcpy( lcdbuf, prompt[mode-4] );\n				UnsignedToAscii( val, lcdbuf+6, 3 );\n				lcdbuf[9] = '.';\n				UnsignedToAscii( fval, lcdbuf+10, 2 + 2*(mode-4) );\n				// unblank leading zeros on fractional part\n				for( val=0; val<3; val++ ){\n					if( lcdbuf[10+val] == ' ' ) \n						lcdbuf[10+val] = '0';\n					else\n						break;\n				}\n				break;\n\n		} // switch( mode )\n		printLCD( 2, lcdbuf, 0 );\n	}\n\n}  //  SupplementalTiming()\n\n/*----------------------------------------------------------------------*\n* FUNCTION: clr_LCDBuf()\n*----------------------------------------------------------------------*/\nvoid clr_LCDBuf( void ){\n\n	uchar i;\n\n	for( i=0; i<LCD_SIZE; i++ )\n		lcdbuf[i] = ' ';\n	lcdbuf[i] = '\\0';\n\n} // clr_LCDBuf()\n\n\n/*-----------------------------------------------------------------------------*\n* Function: External_Interrupt_0()\n*\n*-----------------------------------------------------------------------------*/\nvoid External_Interrupt_0( void ) interrupt 0{\n\n	// SW2 is active low\n	if( switch2 != 0 ){\n		// switch just pressed\n		switch2 = 0;\n		//func2 = !LED2;\n		//LED2 = func2;\n		TimerStart( SWITCH_TIMER, 50 );	// to reset switch2 to 1\n	}\n\n}  //  External_Interrupt_0()\n\n/*-----------------------------------------------------------------------------*\n* Function: External_Interrupt_1()\n*\n*-----------------------------------------------------------------------------*/\nvoid External_Interrupt_1( void ) interrupt 2{\n\n	// SW1 is active low\n	if( switch1 != 0 && !TimerRunning( SWITCH_TIMER )){\n		// switch just pressed\n		switch1 = 0;\n		func1 = TRUE;\n\n		TimerStart( SWITCH_TIMER, 150 );	// to reset switch1 to 1\n	}\n\n}  //  External_Interrupt_1()\n\n/* ----- unused F330 interrupts ----- */\n\n//Reset 0x0000 Top \n//void External_Interrupt_0( void ) interrupt 0{}\n//void Timer0_ISR( void ) interrupt 1{}	// Timer0 used for baud rate\n//void External_Interrupt_1( void ) interrupt 2{}\nvoid Timer_1_Overflow( void ) interrupt 3{}\n//void SioIntService( void ) interrupt 4{}\n//void Timer_2_Overflow( void ) interrupt 5{}\nvoid SPI0( void ) interrupt 6{}\nvoid SMB0( void ) interrupt 7{}\n// reserved 8\nvoid ADC0_Window_Comparator( void ) interrupt 9{}\nvoid ADC0_End_of_Conversion( void ) interrupt 10{}\nvoid Programmable_Counter_Array( void ) interrupt 11{}\nvoid Comparator( void ) interrupt 12{}\n// reserved 13\nvoid Timer_3_Overflow( void ) interrupt 14{}\n\n//-----------------------------------------------------------------------------\n// End Of File\n//-----------------------------------------------------------------------------\n",
			"file": "TSIPMon.c",
			"file_size": 31073,
			"file_write_time": 131139379640000000,
			"settings":
			{
				"buffer_size": 30002,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "   /*-------------------------------------------------------------------------\n   Register Declarations for the Cygnal/SiLabs C8051F33x Processor Range\n\n   Copyright (C) 2004 - Maarten Brock, sourceforge.brock@dse.nl\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n-------------------------------------------------------------------------*/\n\n#ifndef C8051F330_H\n#define C8051F330_H\n\n\n/*  BYTE Registers  */\n\n__sfr __at (0x80) P0           ;  /* PORT 0                                        */\n__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */\n__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */\n__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */\n__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */\n__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */\n__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */\n__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */\n__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */\n__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */\n__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */\n__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */\n__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */\n__sfr __at (0x90) P1           ;  /* PORT 1                                        */\n__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                               */\n__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */\n__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */\n__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                            */\n__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                           */\n__sfr __at (0x96) IDA0L        ;  /* CURRENT MODE DAC 0 - LOW BYTE                 */\n__sfr __at (0x97) IDA0H        ;  /* CURRENT MODE DAC 0 - HIGH BYTE                */\n__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                           */\n__sfr __at (0x98) SCON0        ;  /* SERIAL PORT CONTROL                           */\n__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                            */\n__sfr __at (0x99) SBUF0        ;  /* SERIAL PORT BUFFER                            */\n__sfr __at (0x9B) CPT0CN       ;  /* COMPARATOR 0 CONTROL                          */\n__sfr __at (0x9D) CPT0MD       ;  /* COMPARATOR 0 MODE SELECTION                   */\n__sfr __at (0x9F) CPT0MX       ;  /* COMPARATOR 0 MUX SELECTION                    */\n__sfr __at (0xA0) P2           ;  /* PORT 2                                        */\n__sfr __at (0xA1) SPI0CFG      ;  /* SPI0 CONFIGURATION                            */\n__sfr __at (0xA2) SPI0CKR      ;  /* SPI0 CLOCK RATE CONTROL                       */\n__sfr __at (0xA3) SPI0DAT      ;  /* SPI0 DATA                                     */\n__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */\n__sfr __at (0xA5) P1MDOUT      ;  /* PORT 1 OUTPUT MODE CONFIGURATION              */\n__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */\n__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */\n__sfr __at (0xA9) CLKSEL       ;  /* SYSTEM CLOCK SELECT                           */\n__sfr __at (0xAA) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL             */\n__sfr __at (0xAA) _XPAGE       ;  /* XDATA/PDATA PAGE                              */\n__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                   */\n__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */\n__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */\n__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */\n__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */\n__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */\n__sfr __at (0xB9) IDA0CN       ;  /* CURRENT MODE DAC 0 - CONTROL                  */\n__sfr __at (0xBA) AMX0N        ;  /* ADC 0 MUX NEGATIVE CHANNEL SELECTION          */\n__sfr __at (0xBB) AMX0P        ;  /* ADC 0 MUX POSITIVE CHANNEL SELECTION          */\n__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                           */\n__sfr __at (0xBD) ADC0L        ;  /* ADC 0 DATA WORD LSB                           */\n__sfr __at (0xBE) ADC0H        ;  /* ADC 0 DATA WORD MSB                           */\n__sfr __at (0xC0) SMB0CN       ;  /* SMBUS CONTROL                                 */\n__sfr __at (0xC1) SMB0CF       ;  /* SMBUS CONFIGURATION                           */\n__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS DATA                                    */\n__sfr __at (0xC3) ADC0GTL      ;  /* ADC 0 GREATER-THAN LOW BYTE                   */\n__sfr __at (0xC4) ADC0GTH      ;  /* ADC 0 GREATER-THAN HIGH BYTE                  */\n__sfr __at (0xC5) ADC0LTL      ;  /* ADC 0 LESS-THAN LOW BYTE                      */\n__sfr __at (0xC6) ADC0LTH      ;  /* ADC 0 LESS-THAN HIGH BYTE                     */\n__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                               */\n__sfr __at (0xC8) TMR2CN       ;  /* TIMER 2 CONTROL                               */\n__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */\n__sfr __at (0xCA) TMR2RLL      ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */\n__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */\n__sfr __at (0xCB) TMR2RLH      ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */\n__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                            */\n__sfr __at (0xCC) TMR2L        ;  /* TIMER 2 - LOW BYTE                            */\n__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                           */\n__sfr __at (0xCD) TMR2H        ;  /* TIMER 2 - HIGH BYTE                           */\n__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */\n__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                   */\n__sfr __at (0xD4) P0SKIP       ;  /* PORT 0 SKIP                                   */\n__sfr __at (0xD5) P1SKIP       ;  /* PORT 1 SKIP                                   */\n__sfr __at (0xD8) PCA0CN       ;  /* PCA CONTROL                                   */\n__sfr __at (0xD9) PCA0MD       ;  /* PCA MODE                                      */\n__sfr __at (0xDA) PCA0CPM0     ;  /* PCA MODULE 0 MODE REGISTER                    */\n__sfr __at (0xDB) PCA0CPM1     ;  /* PCA MODULE 1 MODE REGISTER                    */\n__sfr __at (0xDC) PCA0CPM2     ;  /* PCA MODULE 2 MODE REGISTER                    */\n__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */\n__sfr __at (0xE1) XBR0         ;  /* PORT MUX CONFIGURATION REGISTER 0             */\n__sfr __at (0xE2) XBR1         ;  /* PORT MUX CONFIGURATION REGISTER 1             */\n__sfr __at (0xE3) OSCLCN       ;  /* LOW-FREQUENCY OSCILLATOR CONTROL              */\n__sfr __at (0xE4) IT01CF       ;  /* INT0/INT1 CONFIGURATION REGISTER              */\n__sfr __at (0xE4) INT01CF      ;  /* INT0/INT1 CONFIGURATION REGISTER              */\n__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */\n__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                 */\n__sfr __at (0xE9) PCA0CPL1     ;  /* PCA CAPTURE 1 LOW                             */\n__sfr __at (0xEA) PCA0CPH1     ;  /* PCA CAPTURE 1 HIGH                            */\n__sfr __at (0xEB) PCA0CPL2     ;  /* PCA CAPTURE 2 LOW                             */\n__sfr __at (0xEC) PCA0CPH2     ;  /* PCA CAPTURE 2 HIGH                            */\n__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */\n__sfr __at (0xF0) B            ;  /* B REGISTER                                    */\n__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE CONFIGURATION               */\n__sfr __at (0xF1) P0MDIN       ;  /* PORT 0 INPUT MODE CONFIGURATION               */\n__sfr __at (0xF2) P1MODE       ;  /* PORT 1 INPUT MODE CONFIGURATION               */\n__sfr __at (0xF2) P1MDIN       ;  /* PORT 1 INPUT MODE CONFIGURATION               */\n__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */\n__sfr __at (0xF8) SPI0CN       ;  /* SPI0 CONTROL                                  */\n__sfr __at (0xF9) PCA0L        ;  /* PCA COUNTER LOW                               */\n__sfr __at (0xFA) PCA0H        ;  /* PCA COUNTER HIGH                              */\n__sfr __at (0xFB) PCA0CPL0     ;  /* PCA CAPTURE 0 LOW                             */\n__sfr __at (0xFC) PCA0CPH0     ;  /* PCA CAPTURE 0 HIGH                            */\n__sfr __at (0xFF) VDM0CN       ;  /* VDD MONITOR CONTROL                           */\n\n\n/*  WORD/DWORD Registers  */\n\n__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */\n__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */\n__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                               */\n__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                 */\n__sfr16 __at (0xCBCA) TMR2RL   ;  /* TIMER 2 CAPTURE REGISTER WORD                 */\n__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                               */\n__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                 */\n__sfr16 __at (0x9796) IDA0     ;  /* CURRENT MODE DAC 0 DATA WORD                  */\n__sfr16 __at (0xBEBD) ADC0     ;  /* ADC 0 DATA WORD                               */\n__sfr16 __at (0xC4C3) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD              */\n__sfr16 __at (0xC6C5) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                 */\n__sfr16 __at (0xFAF9) PCA0     ;  /* PCA COUNTER                                   */\n__sfr16 __at (0xFCFB) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                            */\n__sfr16 __at (0xEAE9) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                            */\n__sfr16 __at (0xECEB) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                            */\n\n\n/*  BIT Registers  */\n\n/*  P0  0x80 */\n__sbit __at (0x80) P0_0        ;\n__sbit __at (0x81) P0_1        ;\n__sbit __at (0x82) P0_2        ;\n__sbit __at (0x83) P0_3        ;\n__sbit __at (0x84) P0_4        ;\n__sbit __at (0x85) P0_5        ;\n__sbit __at (0x86) P0_6        ;\n__sbit __at (0x87) P0_7        ;\n\n/*  TCON  0x88 */\n__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */\n__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */\n__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */\n__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */\n__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */\n__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */\n__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */\n__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */\n\n/*  P1  0x90 */\n__sbit __at (0x90) P1_0        ;\n__sbit __at (0x91) P1_1        ;\n__sbit __at (0x92) P1_2        ;\n__sbit __at (0x93) P1_3        ;\n__sbit __at (0x94) P1_4        ;\n__sbit __at (0x95) P1_5        ;\n__sbit __at (0x96) P1_6        ;\n__sbit __at (0x97) P1_7        ;\n\n/*  SCON  0x98 */\n__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */\n__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */\n__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */\n__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */\n__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */\n__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                        */\n__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */\n__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                       */\n__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */\n__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */\n__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */\n__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */\n__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */\n__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */\n\n/*  P2  0xA0 */\n__sbit __at (0xA0) P2_0        ;\n__sbit __at (0xA1) P2_1        ;\n__sbit __at (0xA2) P2_2        ;\n__sbit __at (0xA3) P2_3        ;\n__sbit __at (0xA4) P2_4        ;\n__sbit __at (0xA5) P2_5        ;\n__sbit __at (0xA6) P2_6        ;\n__sbit __at (0xA7) P2_7        ;\n\n/*  IE  0xA8 */\n__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */\n__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */\n__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */\n__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */\n__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */\n__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */\n__sbit __at (0xAD) ET2         ;  /* IE.5 - TIMER 2 INTERRUPT ENABLE               */\n__sbit __at (0xAE) ESPI0       ;  /* IE.6 - SPI0 INTERRUPT ENABLE                  */\n__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */\n\n/*  IP  0xB8 */\n__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */\n__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */\n__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */\n__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */\n__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */\n__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */\n__sbit __at (0xBD) PT2         ;  /* IP.5 - TIMER 2 PRIORITY                       */\n__sbit __at (0xBE) PSPI0       ;  /* IP.6 - SPI0 PRIORITY                          */\n\n/*  SMB0CN  0xC0 */\n__sbit __at (0xC0) SI          ;  /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG     */\n__sbit __at (0xC1) ACK         ;  /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG           */\n__sbit __at (0xC2) ARBLOST     ;  /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */\n__sbit __at (0xC3) ACKRQ       ;  /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST        */\n__sbit __at (0xC4) STO         ;  /* SMB0CN.4 - SMBUS 0 STOP FLAG                  */\n__sbit __at (0xC5) STA         ;  /* SMB0CN.5 - SMBUS 0 START FLAG                 */\n__sbit __at (0xC6) TXMODE      ;  /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR    */\n__sbit __at (0xC7) MASTER      ;  /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR     */\n\n/*  TMR2CN  0xC8 */\n__sbit __at (0xC8) T2XCLK      ;  /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT      */\n__sbit __at (0xCA) TR2         ;  /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL             */\n__sbit __at (0xCB) T2SPLIT     ;  /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE          */\n__sbit __at (0xCD) TF2CEN      ;  /* TMR2CN.5 - TIMER 2 LOW-FREQ OSC CAPTURE ENABLE*/\n__sbit __at (0xCD) TF2LEN      ;  /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE  */\n__sbit __at (0xCE) TF2L        ;  /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG     */\n__sbit __at (0xCF) TF2         ;  /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG              */\n__sbit __at (0xCF) TF2H        ;  /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG    */\n\n/*  PSW  0xD0 */\n__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */\n__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */\n__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */\n__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */\n__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */\n__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */\n__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */\n__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */\n\n/*  PCA0CN  0xD8 */\n__sbit __at (0xD8) CCF0        ;  /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG  */\n__sbit __at (0xD9) CCF1        ;  /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG  */\n__sbit __at (0xDA) CCF2        ;  /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG  */\n__sbit __at (0xDE) CR          ;  /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL      */\n__sbit __at (0xDF) CF          ;  /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG    */\n\n/*  ADC0CN  0xE8 */\n__sbit __at (0xE8) AD0CM0      ;  /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0    */\n__sbit __at (0xE9) AD0CM1      ;  /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1    */\n__sbit __at (0xEA) AD0CM2      ;  /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2    */\n__sbit __at (0xEB) AD0WINT     ;  /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG     */\n__sbit __at (0xEC) AD0BUSY     ;  /* ADC0CN.4 - ADC 0 BUSY FLAG                    */\n__sbit __at (0xED) AD0INT      ;  /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG     */\n__sbit __at (0xEE) AD0TM       ;  /* ADC0CN.6 - ADC 0 TRACK MODE                   */\n__sbit __at (0xEF) AD0EN       ;  /* ADC0CN.7 - ADC 0 ENABLE                       */\n\n/*  SPI0CN  0xF8 */\n__sbit __at (0xF8) SPIEN       ;  /* SPI0CN.0 - SPI0 ENABLE                        */\n__sbit __at (0xF9) TXBMT       ;  /* SPI0CN.1 - TRANSMIT BUFFER EMPTY              */\n__sbit __at (0xFA) NSSMD0      ;  /* SPI0CN.2 - SLAVE SELECT MODE BIT 0            */\n__sbit __at (0xFB) NSSMD1      ;  /* SPI0CN.3 - SLAVE SELECT MODE BIT 1            */\n__sbit __at (0xFC) RXOVRN      ;  /* SPI0CN.4 - RECEIVE OVERRUN FLAG               */\n__sbit __at (0xFD) MODF        ;  /* SPI0CN.5 - MODE FAULT FLAG                    */\n__sbit __at (0xFE) WCOL        ;  /* SPI0CN.6 - WRITE COLLISION FLAG               */\n__sbit __at (0xFF) SPIF        ;  /* SPI0CN.7 - SPI0 INTERRUPT FLAG                */\n\n\n/* Predefined SFR Bit Masks */\n\n#define PCON_IDLE         0x01    /* PCON                                */\n#define PCON_STOP         0x02    /* PCON                                */\n#define T1M               0x08    /* CKCON                               */\n#define PSWE              0x01    /* PSCTL                               */\n#define PSEE              0x02    /* PSCTL                               */\n#define ECP0              0x20    /* EIE1                                */\n#define PORSF             0x02    /* RSTSRC                              */\n#define SWRSF             0x10    /* RSTSRC                              */\n#define ECCF              0x01    /* PCA0CPMn                            */\n#define PWM               0x02    /* PCA0CPMn                            */\n#define TOG               0x04    /* PCA0CPMn                            */\n#define MAT               0x08    /* PCA0CPMn                            */\n#define CAPN              0x10    /* PCA0CPMn                            */\n#define CAPP              0x20    /* PCA0CPMn                            */\n#define ECOM              0x40    /* PCA0CPMn                            */\n#define PWM16             0x80    /* PCA0CPMn                            */\n#define CP0E              0x10    /* XBR0                                */\n#define CP0OEN            0x10    /* XBR0                                */\n#define CP0AE             0x20    /* XBR0                                */\n#define CP0AOEN           0x20    /* XBR0                                */\n\n#endif\n",
			"file": "c8051f330.h",
			"file_size": 21341,
			"file_write_time": 128749591200000000,
			"settings":
			{
				"buffer_size": 21034,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Extdebug.c",
			"settings":
			{
				"buffer_size": 4635,
				"line_ending": "Windows"
			}
		},
		{
			"file": "extdebug.h",
			"settings":
			{
				"buffer_size": 471,
				"line_ending": "Windows"
			}
		},
		{
			"file": "general.h",
			"settings":
			{
				"buffer_size": 4663,
				"line_ending": "Windows"
			}
		},
		{
			"file": "GPS_if.h",
			"settings":
			{
				"buffer_size": 4136,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 87.0,
		"last_filter": "install",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"pack remo",
				"Package Control: Remove Package"
			],
			[
				"pack in",
				"Package Control: Install Package"
			],
			[
				"Insta",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 174.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Volumes/Murray/Users/kmurphy/Downloads/PK2DeviceFile v1.63.148_150721.dat",
		"/Volumes/Murray/Users/kmurphy/Downloads/v034 - 20digit - GPS offset read from TB/tsip.sublime-project",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/libraries/FutabaSD08FA/FutabaSD08FA.cpp",
		"/Volumes/Murray/Users/kmurphy/Library/Application Support/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/Library/QuickLook/QLColorCode.qlgenerator/Contents/Info.plist",
		"/Volumes/Murray/Users/kmurphy/Downloads/partsbox.io/partsbox-data-2016-07-19.json",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/libraries/Rotary/rotary.h",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/libraries/Rotary/rotary.cpp",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/libraries/Rotary/examples/rotary/rotary.ino",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/libraries/Rotary/keywords.txt",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/libraries/DHT_sensor_library/DHT.cpp",
		"/Volumes/Murray/Users/kmurphy/Library/Scripts/sin_maker.py",
		"/Volumes/Murray/Users/kmurphy/Downloads/ZL1CVD-TSIPv1/tbolt2lcd.pnproj",
		"/Volumes/Murray/Users/kmurphy/Downloads/ZL1CVD-TSIPv1/main.c",
		"/Volumes/Murray/Users/kmurphy/Downloads/SDG 6 Digit clock/main.c",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/SMDReflowOven/SMDReflowOven.ino",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/dummyLoad/dummyLoad.ino",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/libraries/fontsBIGREDLED.h/fontsBIGREDLED.h",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/_64x32matrix/_64x32matrix.ino",
		"/Volumes/Murray/Users/kmurphy/Documents/Arduino/Matrix_LED_6432_PK/Matrix_LED_6432_PK.ino",
		"/Volumes/Murray/Users/kmurphy/Downloads/8x8 Led Box/Program HEX and C file/888.c",
		"/Applications/EAGLE/scr/eagle.scr",
		"/Volumes/Murray/Users/kmurphy/test.scr",
		"/Applications/EAGLE/ulp/teardrops.ulp",
		"/Applications/EAGLE-7.6.0/scr/eagle.scr",
		"/Volumes/Murray/Users/kmurphy/.Trash/Recovered files/Temp File 1.tmp",
		"/Volumes/Murray/Users/kmurphy/E48.csv",
		"/Volumes/Murray/Users/kmurphy/Downloads/partsbox-data-2016-04-21.json",
		"/Volumes/Murray/Users/kmurphy/Documents/AVR/Demo/firmware/main.c",
		"/Volumes/Murray/Users/kmurphy/Downloads/partsbox-data-2016-04-15.json",
		"/Volumes/Murray/Users/kmurphy/Desktop/Work/LiquidCrystal_I2C/LiquidCrystal_I2C.h",
		"/Volumes/Murray/Users/kmurphy/Desktop/Work/LiquidCrystal_I2C/LiquidCrystal_I2C.cpp",
		"/Volumes/users2/kmurphy/My Documents/MPLAB/SDG6DigitClock/main.c",
		"/Volumes/Murray/Users/kmurphy/Downloads/old/3.2inch_Arduino_Mega2560_ILI9481_V1.0/Tools-Image2Lcd 2.9/qq_logoUE.c",
		"/Volumes/Murray/Users/kmurphy/Downloads/old/3.2inch_Arduino_Mega2560_ILI9481_V1.0/tft_drivers/setxy.h",
		"/Volumes/Murray/Users/kmurphy/Downloads/old/3.2inch_Arduino_Mega2560_ILI9481_V1.0/tft_drivers/initlcd.h",
		"/Volumes/RECOVERY/os/openelec/os.json",
		"/Volumes/RECOVERY/os/RaspBMC/os.json",
		"/Volumes/RECOVERY/os/RISC_OS/os.json",
		"/Volumes/Murray/Users/kmurphy/.bashrc",
		"/Volumes/Murray/Users/kmurphy/.bash_rc",
		"/Volumes/Murray/Users/kmurphy/Sites/SomerledDesign/javascript.htm",
		"/Volumes/Murray/Users/kmurphy/Downloads/snippet.cgi",
		"/Volumes/Murray/Users/kmurphy/Downloads/snippet-7.cgi",
		"/Volumes/Murray/Users/kmurphy/Downloads/snippet-6.cgi",
		"/Volumes/Murray/Users/kmurphy/Downloads/snippet-5.cgi",
		"/Volumes/Murray/Users/kmurphy/Downloads/snippet-4.cgi",
		"/Volumes/Murray/Users/kmurphy/Downloads/snippet-3.cgi",
		"/Volumes/Murray/Users/kmurphy/Downloads/snippet-2.cgi",
		"/Volumes/Murray/Users/kmurphy/Sites/Rigol/www.gotroot.ca/rigol/riglol/riglol.js",
		"/Volumes/Murray/Users/kmurphy/.bashrc_help.no_color",
		"/Volumes/Murray/Users/kmurphy/.bashrc_help",
		"/Volumes/Murray/Users/kmurphy/.bash_history",
		"/Volumes/Murray/Users/kmurphy/.profile",
		"/Volumes/Murray/Users/kmurphy/Library/Scripts/UPT.sh",
		"/Volumes/Murray/Users/kmurphy/Library/Scripts/ESCGEN",
		"/Volumes/Murray/Users/kmurphy/Library/Scripts/CLOCKtput",
		"/Volumes/Murray/Users/kmurphy/Library/Scripts/CLOCK",
		"/Volumes/Murray/Users/kmurphy/Library/Scripts/COLORS.sh",
		"/Volumes/Murray/Users/kmurphy/Library/Scripts/ELITE",
		"/Volumes/Murray/Users/kmurphy/Library/Scripts/TONKA",
		"/private/etc/bashrc",
		"/Volumes/Murray/Users/kmurphy/Documents/Azureus Downloads/The Color Of Money/The Color Of Money-English.srt",
		"/Volumes/Untitled/config.txt",
		"/Volumes/Murray/Users/kmurphy/Music/iTunes Library"
	],
	"find":
	{
		"height": 32.0
	},
	"find_in_files":
	{
		"height": 102.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"\\s\\s",
			"^$",
			"\\s\\s",
			"0b([10]{7},)",
			"0b([10]{6},)",
			"0b([10]{5},)",
			"0b([10]{1},)",
			"0b([10]{2},)",
			"0b([10]{3},)",
			"0b([10]{4},)",
			"0x",
			"0x0,",
			"0x",
			",\n",
			"0x",
			",\n",
			"0x",
			"*/ ",
			", ",
			",",
			", ",
			"\\,.",
			",\n",
			", ",
			",  ",
			", ",
			"\\,.",
			"\\,",
			"\\s",
			"/(\\s)\\g",
			"/(\\s)",
			"href",
			"grep"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"  ",
			",",
			"0b0$1",
			"0b00$1",
			"0b0000000$1",
			"0b000000$1",
			"0b00000$1",
			"0b0000$1",
			"0b",
			"0x00000000,",
			"\\,\\\\r",
			"\\,^p"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 7,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "iconv.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8341,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "iconv.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 808,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "lcd_if.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15651,
						"regions":
						{
						},
						"selection":
						[
							[
								4207,
								4207
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1954.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "lcd_if.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1069,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "timer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 883,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "TSIP.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10459,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 6242.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "TSIPMon.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 30002,
						"regions":
						{
						},
						"selection":
						[
							[
								81,
								81
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 8712.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "c8051f330.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21034,
						"regions":
						{
						},
						"selection":
						[
							[
								3,
								3
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "Extdebug.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4635,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "extdebug.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 471,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "general.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4663,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "GPS_if.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4136,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 32.0
	},
	"input":
	{
		"height": 38.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.astyle_error_message":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "tsip.sublime-project",
	"replace":
	{
		"height": 60.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 189.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
